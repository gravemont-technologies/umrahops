# DEMO_SPEC_AND_GAP_ANALYSIS.md

**Purpose:** deliver a single, implementable specification (visual + data + API + DB migration + priority plan) that converts the requested interactive **“View Demo”** (visual walkthrough of a user’s work day + draggable profile overlay + rule-based assistant + TODOs/objectives/BOOSTs/HELP) into an MVP that plugs into the current `umrahops` repo and Supabase schema. Where the repo already supports pieces, we map to existing tables; where it does not, we add the *minimum* schema and API surface required.

Source reference: core repo README and schema summary (used to map existing tables: `groups`, `travelers`, `hotels`, `bookings`, `audit_logs`, `jobs_queue`). ([GitHub][1])

---

## 1 — High-level product behaviour (what the demo must do)

1. Replace the current **View Documentation** entry point with **View Demo** (a fully visual, clickable-only interactive demo).
2. The demo walks through a single “work day” scenario for an operations coordinator who:

   * coordinates groups,
   * inspects/upserts traveler rows imported from Excel/CSV,
   * verifies hotel booking status (hotel stays, check-ins),
   * uses a draggable **profile overlay** that shows *all* saved info for one person,
   * uses stage-level buttons to auto-generate messages for status/verification (templates),
   * tracks adaptive TODOs in an **Objectives** tab (filterable by time, urgency, status),
   * exposes a **HELP** tab and a **BOOSTs** section of concise daily productivity “how-tos”.
3. The demo is purely visual and clickable; interactions are limited to button clicks, toggles and in-demo navigation (no persistent writes in demo mode unless user accepts — but MVP will allow real writes when in production).
4. Everything must be anchored to the existing DB schema; only add columns/tables when necessary and keep changes minimal and backwards compatible. ([GitHub][1])

---

## 2 — UX / UI spec (visual walkthrough)

### 2.1 Entry

* Landing CTA: **View Demo** (replaces existing View Documentation). Clicking opens the demo modal (full-screen overlay).
* Demo modal has upper toolbar: `Scenario ►` (dropdown of scenarios; default: “Daily Coordination — Hotel Verification”), `Switch: Demo Mode / Live Mode`.

### 2.2 Main panes (left → center → right)

* Left: **Groups list** (compact) — select group shows summary (group name, status, steps_completed). Each group row has a small step indicator (1–6).
* Center: **Workflow stage view** (main canvas)

  * Top: breadcrumb of coordination stages (e.g., Upload → Validate → Assign → Verify (hotel) → Confirm → Close).
  * Large central timeline card for the selected stage with `Primary CTA` (Generate message / Request verification / Mark as TODO).
  * Each coordination stage exposes 1–3 contextual buttons that produce messages or create TODOs.
* Right: **Draggable Profile Overlay** (floating card)

  * Shows single-person canonical view (sourced from `travelers`): name, passport_hash (masked), risk_score, nusuk_status, message_status, bookings, notes, raw imported row preview, and action buttons: `Generate message`, `Create TODO`, `Open Objectives`.
  * Overlay is draggable and pinnable. In demo mode it moves but doesn’t change server state (unless Live Mode).

### 2.3 Objectives tab (bottom or right secondary panel)

* **Filter bar:** timeframe (Today / 24h / 3d / 7d / custom), urgency (Low / Medium / High), status (Open / In progress / Done), assigned (auto / manual).
* **TODO rows** show: source (system / user), reason (auto-generated by GPT API), target (group | traveler | hotel), due_at, urgency_score (from GPT / API), linked item (hotel record / traveler row) and a small action menu: `Mark done` (moves to archive + audit), `Open profile`, `View message`.
* TODO lifecycle: created → assigned → completed → archived (stored in `audit_logs`).

### 2.4 HELP tab + BOOSTs

* HELP: short FAQ-style collapsibles (e.g., “How do I check hotel booking status?”, “How to refresh NUSUK data?”, “How to use Objectives filters”). Each entry is 1–4 lines. (Keep content concrete and prescriptive.)
* BOOSTs: short tiles (title only) with expand action. Examples:

  * “Ask questions to your Excel file” → expands to 4 bullet step-by-step: 1) Upload → 2) Map columns → 3) Click ‘Ask’ → 4) Use template prompts → (example prompt for Microsoft Copilot).
  * “Fast hotel verification” → 3 step checklist with recommended WhatsApp template & fallback.
* Keep BOOSTs short, actionable, and copyable.

---

## 3 — Buttons & message generation behavior (coordination stage rules)

Each coordination stage exposes one or more buttons that generate messages or actions. Buttons call a message-generation API that uses:

* stage identifier,
* linked entity (group/traveler/hotel),
* message template id,
* variables resolved from DB (e.g., traveler name, check_in, booking_id),
* urgency flag.

### 3.1 Example buttons (for the hotel verification stage)

* **Generate status request**

  * Input: hotel_id, group_id, booking_id (optional)
  * Action: calls `POST /api/messages/generate` with template type `hotel_status_request`.
  * Output: prefilled message shown in a preview modal (button: `Send via WhatsApp` or `Copy`).
* **Keep requesting status** (escalation)

  * Action: generates a short, escalating message; if clicked repeatedly within a time window, it changes tone from polite → urgent → firm. The escalation level is stored on TODO row to avoid repeated duplicates.
* **Immediate verification / confirmation**

  * Action: when the hotel replies (tracked via messageStatus or manual confirm), allow `Confirm booked` button. If traveler's imported row shows booking column — the UI displays TODO to change status to `booked` (MVP message: TODO to change to `booked`). The Objectives tab holds this as actionable item (filterable).
  * The `Confirm booked` action updates `bookings` and marks the TODO done and posts an `audit_logs` entry.

### 3.2 Message templates (minimum set)

* `hotel_status_request` — variables: {hotel_name}, {date}, {group_ref}, {requestor_name}
* `hotel_status_confirm` — variables: {hotel_name}, {room_count}, {check_in}
* `reminder_escalation_{level}` — level ∈ {1,2,3}
* `colleague_nudge_funny` — small witty template for “My colleague won’t stop delaying”
* Templates are stored in `message_templates` (DB table suggested below). The generator uses rules to pick tone and escalation based on previous interactions and TODO urgency.

---

## 4 — Rule-based chatbot spec

* The user specifically asked for a `.md` they can use to create a chatbot. Deliverable `docs/assistant_rules.md` includes:

  * Trigger patterns (regex / intent mapping).
  * Rule actions (generate template X, escalate TODO, show profile overlay).
* Each rule returns: `text`, `template_id` (if applicable), `action` (none | create_todo | api_call), `ai_confidence` (optional). Save rules to `chat_rules` table for dynamic editing.

---

## 5 — Data model changes (SQL migrations) — minimal and pragmatic

**Principles:** keep existing tables untouched; add new tables referenced by the UI. Use `uuid` primary keys to match Supabase style; created_at/updated_at; FK constraints; link to `audit_logs` on mutations.

Reconciled with Drizzle ORM (`shared/schema.ts`):

### 5.1 New table — `todos` (objectives)

(See `db/migrations/20260202_final_schema.sql` for full SQL)

```typescript
export const todos = sqliteTable("todos", {
  id: text("id").primaryKey(),
  groupId: text("group_id").references(() => groups.id),
  // ... (see shared/schema.ts)
  status: text("status").default("open"),
  urgency: text("urgency").default("medium"),
});
```

### 5.2 New table — `message_templates`
### 5.3 New table — `boosts`
### 5.4 New table — `chat_rules`

### 5.5 Minor additions (if helpful)

* Add `overlay` JSON column to `travelers` **only if** overlay needs fields not covered in travelers:

```typescript
overlay: text("overlay", { mode: "json" }).default("{}"),
```

**Audit & integrity rules**:

* Ensure every `todos` state change writes an `audit_logs` row (there is an existing `audit_logs` table). Implement that as a server-side transaction (or a Postgres trigger that calls a function to insert into `audit_logs`). Prefer server code (API) to ensure audit chain integrity with hashed payload as repo expects. ([GitHub][1])

---

## 6 — API surface (minimal endpoints & semantics)

These endpoints are intended to be added under `api/` (server) and exposed to the client with proper auth.

### messages

* `POST /api/messages/generate`
  Body: `{ template_name, group_id?, traveler_id?, hotel_id?, booking_id?, escalation_level?, mode: "demo"|"live" }`
  Response: `{ preview_text, variables_resolved, template_id }`

* `POST /api/messages/send`
  Body: `{ preview_text, channel, target_contact, metadata }`
  Sends (or in demo mode returns wa://deep link). Tracks message_status on `travelers`/`bookings` as appropriate.

### todos

* `POST /api/todos` — create
* `PATCH /api/todos/:id` — update status/assigned/due
* `GET /api/todos?group_id=&status=&urgency=&from=&to=` — filtered listing

### profiles

* `GET /api/profiles/:traveler_id` — returns traveler + overlay + bookings + last_messages
* `GET /api/groups/:id/summary` — quick group summary for demo breadcrumb
* `POST /api/bookings/:id/confirm` — confirm & write audit log

**Server behaviour:** all stateful endpoints must:

* validate input with canonical validator (Zod is already used in repo),
* write to DB via `dbService` (Drizzle or existing db code),
* append to `audit_logs` using existing audit chain method (hashing prev + payload + timestamp) if production. In demo mode return preview and do not write.

---

## 7 — Integration to Supabase (production notes)

* Use existing dual-mode strategy: demo mode should not touch Supabase; live mode writes to Supabase.
* Add RLS policies only if new tables added. Keep conservative: `enabled = false` until policies are written for specific roles. (Repo notes say RLS needs tuning.) ([GitHub][1])
* Use Supabase functions for heavy jobs only if necessary. Prefer server-side application layer for message generation, TODO assignment, and audit logging.

---

## 8 — Mapping of requested features → current repo status (GAP ANALYSIS)

**What repo already contains (per README / feature status):**

* CSV ingestion, canonical validator, SQLite + Supabase dual-mode approach, messageService for WhatsApp deep links, workflow engine (1–6 steps), audit logging. ([GitHub][1])

**Gaps vs requested features:**

1. **Draggable profile overlay UI** — *UI implementation only; repo has traveler data but not overlay component.*
   → *Gap:* Frontend component needed.
2. **Objectives (interactive TODOs) persisted to DB** — *No dedicated todos table in repo summary.*
   → *Gap:* Need `todos` table + endpoints + UI.
3. **Message templates with escalation & per-stage buttons** — *Repo has messageService (deep links) but no template table / escalation logic.*
   → *Gap:* `message_templates` table + generator service.
4. **BOOSTs & HELP structured content** — *No structured boosts/faqs table referenced.*
   → *Gap:* `boosts` table or static file.
5. **Rule-based chatbot specification** — *Repo has AI service (risk scoring) and ai.md exists but not rule engine for chat.*
   → *Gap:* chat rules table + chatbot integration as a separate microservice or hosted MD.
6. **Linking TODOs to audit chain + Supabase logging** — *Audit exists; must be wired to TODO lifecycle transactions.*
   → *Gap:* server transaction wiring.
7. **Demo mode UI behavior** — *Demo vs Live switching concept is not explicit.*
   → *Gap:* UI & server flags to sandbox demo interactions.

---

## 9 — Minimal prioritized implementation plan (highest → lowest impact)

**Priority 1 — Core infrastructure to support demo**

1. Add `todos` table + endpoints. Implement server logic so creating/completing todos writes `audit_logs`. (High impact — controls Objectives.)
2. Add `message_templates` table + generator endpoint (`/api/messages/generate`). Wire generator to messageService to produce deep links (demo returns preview only). (High impact — powers buttons.)
3. Frontend: implement **View Demo** modal and the **draggable profile overlay** using existing traveler API (`/api/profiles/:id`). Demo mode should default to sandbox and show sample data if no DB exists.

**Priority 2 — UX polish and rule engine**
4. Add `chat_rules` and minimal rule engine that maps triggers to responses and easily readable actions. Export `assistant_rules.md` for direct chatbot import (user requested). (Medium impact.)
5. Add `boosts` & static HELP content (can be seeded via SQL or static JSON). (Medium impact.)

**Priority 3 — Optional safety & optimisation**
6. Implement escalation state tracking for templates (store last escalation level in `todos` or `bookings`). (Low-medium)
7. Add Postgres triggers or server cron for escalation reminders (use `jobs_queue` existing system). (Low)

[1]: https://github.com/truegvmt/umrahops "GitHub - truegvmt/umrahops"
